[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "MicroPs Week 10 Reflections\n\n\n\n\n\nThe End of the Labs (almost)\n\n\n\n\n\nNov 8, 2024\n\n\nJordan Carlin\n\n\n\n\n\n\n\n\n\n\n\n\nMicroPs Week 9 Reflections\n\n\n\n\n\nProject Thoughts and Nearing the End of Labs\n\n\n\n\n\nNov 1, 2024\n\n\nJordan Carlin\n\n\n\n\n\n\n\n\n\n\n\n\nMicroPs Week 8 Reflections\n\n\n\n\n\nRISC-V Everywhere\n\n\n\n\n\nOct 25, 2024\n\n\nJordan Carlin\n\n\n\n\n\n\n\n\n\n\n\n\nMicroPs Week 7 Reflections\n\n\n\n\n\nLabs Labs Labs\n\n\n\n\n\nOct 18, 2024\n\n\nJordan Carlin\n\n\n\n\n\n\n\n\n\n\n\n\nMicroPs Week 6 Reflections\n\n\n\n\n\nFinal Project Kickoff?? Already?!\n\n\n\n\n\nOct 16, 2024\n\n\nJordan Carlin\n\n\n\n\n\n\n\n\n\n\n\n\nMicroPs Week 5 Reflections\n\n\n\n\n\nPCBs?\n\n\n\n\n\nOct 4, 2024\n\n\nJordan Carlin\n\n\n\n\n\n\n\n\n\n\n\n\nMicroPs Week 4 Reflections\n\n\n\n\n\nVictory! And Lots of FSMs…\n\n\n\n\n\nSep 27, 2024\n\n\nJordan Carlin\n\n\n\n\n\n\n\n\n\n\n\n\nMicroPs Week 3 Reflections\n\n\n\n\n\nThe Pain of the Keypad Scanner\n\n\n\n\n\nSep 20, 2024\n\n\nJordan Carlin\n\n\n\n\n\n\n\n\n\n\n\n\nMicroPs Week 2 Reflections\n\n\n\n\n\nThe return of Verilog\n\n\n\n\n\nSep 13, 2024\n\n\nJordan Carlin\n\n\n\n\n\n\n\n\n\n\n\n\nMicroPs Week 1 Reflections\n\n\n\n\n\nWow! That’s a lot of soldering!\n\n\n\n\n\nSep 6, 2024\n\n\nJordan Carlin\n\n\n\n\n\n\n\n\n\n\n\n\nInitial Learning Goals\n\n\n\n\n\nWhat I want to get out of MicroPs\n\n\n\n\n\nAug 30, 2024\n\n\nJordan Carlin\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/week-1-blog.html",
    "href": "posts/week-1-blog.html",
    "title": "MicroPs Week 1 Reflections",
    "section": "",
    "text": "Wow! Lab 1 is in the books. For a lab that seemed so simple, it sure took a while (18 hours!). With this lab, the difficulty was mostly in all of the setup. I’ve soldered plenty before, but never anything like this! All of the tiny SMT components were crazy (it felt like I needed a magnifying glass!) and there were enough through-hole components to drive anyone crazy. Right when I thought I was done with all the preparation, I ran into roadblock after roadblock getting all the software setup and ready to go. From magical cables (my cable didn’t work to flash the J-Link firmware onto my MCU but after using another cable to flash it mine worked fine for programming) to crazy synthesis (Radiant will synthesize on my Linux partition but won’t program the FPGA) to utterly nonsensical Questa issues (It only works if I manually create the work library, launch it using one of the Questa buttons in Lattice, close it, and relaunch it using the other button), there were lots of speed-bumps getting everything ready to go. Now that it is all (mostly) working though, I’m excited to get going on the future labs that will let me focus more on the actual design. Looking forward to getting into some more complicated Verilog projects with lab 2!"
  },
  {
    "objectID": "posts/week-7-blog.html",
    "href": "posts/week-7-blog.html",
    "title": "MicroPs Week 7 Reflections",
    "section": "",
    "text": "It’s catchup week! Due to a variety of other things going on, I’ve fallen pretty far behind on the labs the last few weeks. This past week along with the next few days are all about getting back on top of things and getting caught up on the labs. My reflections won’t be as in depth on each individual lab since there are multiple to cover, but I’m looking forward to being up to date with the labs again.\nLet’s start with Lab 4, the music lab. This was the first lab that involved the MCU. It’s been a while since I’ve done much C embedded C programming, so it took me a little while to get back into the swing of things. There were also a lot of small nuances to the timers that tripped me up. One particularly interesting one was when notes would stop playing in the middle of my song. It would randomly skip a few notes before starting up again. This baffled me for quite a while, until I discovered that it was because I was setting bits in the register that controls the duty cycle, but not clearing them first. Once I switched from orring the bits with my new desired value to directly overwriting it with an equals sign, everything started working. It really goes to show that the tiniest of details can make a world of difference on projects like these.\nOn the labs 5 and 6 front, I’m in the process of finishing up lab 5 right now. While I am familiar with the concept of interrupts (and even their implementation inside a RISC-V processor), I had never actually used them in a program that I wrote before. It was interesting and insightful to actually use them for a change. I’m looking forward to getting it fully working and detecting the motor speed. I’m hoping to get started on Lab 6 in the next day or two, which should be quite useful because we plan to use SPI to communicate between the MCU and FPGA for our final project.\nAs as final thought for this week, I’m looking forward to the North American RISC-V Summit next week. While MicroPs does not do anything RISC-V based, it is still closely connected to computer architecture and digital design so ties nicely into this class. I’ll be attending with Prof. Harris’s research lab (the Clay Wolkin Fellowship) and am excited to meet many of the people I’ve heard about or spoken to online in person."
  },
  {
    "objectID": "posts/week-5-blog.html",
    "href": "posts/week-5-blog.html",
    "title": "MicroPs Week 5 Reflections",
    "section": "",
    "text": "I’ve had very little experience designing PCBs, so this was interesting week for me. I was involved in some of the initial design discussions and schematic creation for a signal board for MuddSub (Harvey Mudd’s RoboSub team), but never got to far into that process. While I understand the point of a PCB and the general idea behind how they are designed, I’d never created one entirely myself before. While the overall process was definitely interesting, I’m surprised by how manual the whole process still is (it is possible this is a result of using KiCAD instead of something like Altium).\nThe built in libraries of parts make creating a schematic fairly straightforward, but the routing itself was a real pain. The “rat’s nest” makes it easier so that it is at least clear what needs to be connected, but it really seems like there would be a way for it to automatically do the routing and figure out an optimal layout (that could then be fine tuned if needed). While the manual process is kind of fun, it’s also very tedious and got old quickly.\nOverall, this was interesting experience and I’m excited to see if my board works. I wouldn’t be surprised if there were some problems with it since it is my first one, but it would be great to use a board that I designed for one of the labs."
  },
  {
    "objectID": "posts/week-10-blog.html",
    "href": "posts/week-10-blog.html",
    "title": "MicroPs Week 10 Reflections",
    "section": "",
    "text": "The end of the labs is at hand. It’s hard to believe that I am nearly done with the labs. I made a lot of progress getting caught up on my backlog oif labs this past week. I went back and fixed up lab 4, did lab 5, and nearly completed lab 6.\nWit lab 4, I had mostly finished it several weeks ago. There was just one problem: my songs played at half the expected tempo. The strange things about this was that they had the same frequency, which seemed to imply the issue was in my delay timer and not in the main clock generated by the PLL. After lots of fruitless searching and attempts to correct the problem, I decided to very carefully review my PLL RCC configuration, and there it was. I had shifted all of my bits for one of the PLL registers over by one to the right, so the clo0ck was running at half the expected speed. The reason this had slipped by me was that I also had a misconception (possibly because my frequencies were initially wrong, I no longer remember) in my frequency configuration and thought that I needed to divide one of the values by two that really shouldn’t have been divided. This resulted in me getting the right frequency and masking my main error.\nLab 5 was an interesting one. Once I was familiar with how interrupts work, it really wasn’t all that bad. I had some issues with the specific configuration of a few items, but was generally able to get this one up and running fairly quickly and painlessly. Lab 6 on the other hand has proven to be a nightmare. After countless hours of the WiFi network from my ESP coming and going, I found out that for some reason the CE signal needs to be tied high or the network is not broadcast. However, after doing this the ESP no longer seemed to be communicating with the MCU properly. The MCU was convinced that it was not receiving any requests from the ESP, despite the transmission clearly coming across on the UART line when viewed with a logic analyzer. This is still an unsolved issue with no clear solution. Looking in the debugger, the UART registers all seem to be configured correctly and the data is reaching the MCU, but for some reason it is not being recognized. For now we are declaring this a lost cause and moving on. I might revisit it later, but my plan to wrap up lab 6 is to skip the ESP and just get the MCU communicating with the temperature sensor and view the SPI packets on the logic analyzer (and maybe using a printf statement to view them in the debugger).\nLooking forward to putting the finishing touches on these labs and moving on to focusing my energy on our final project. More to come on the progress we’ve made with out final project in my next post."
  },
  {
    "objectID": "posts/week-6-blog.html",
    "href": "posts/week-6-blog.html",
    "title": "MicroPs Week 6 Reflections",
    "section": "",
    "text": "Hard to believe that it is already time to get started with the final projects for this class. This is the part of the class that I think is by far the most well known and probably the most fun, but also the most work. Part of what makes it fun is getting to decide what it is that you’re creating. That’s the subject of this blog post.\nI’m going to be working with Zoe for the final project, and we both quickly agreed that we wanted to do a project involving a display. The question was what. We threw around lots of different ideas, from something that was drawing out representations of interesting mathematical concepts to a maze that people had to solve, before finally settling on something more creative in nature. We’re going to create a better version of an etch-a-sketch with lots of new bells and whistles. In addition to drawing based on how you control a joystick (replacing the traditional 2 knobs), our system will allow you to select the color and brush width and even lift the pen up. It will almost be like those Python turtle graphics programs for learning to code, except instead of Python code controlling where the pen goes it will be a person interfacing with the system.\nI’m excited to dive back into the FPGA in earnest for this project. Figuring out when to redraw part of the screen based on input from the MCU (probably an FSM) will be an interesting challenge, but what I’m envisioning taking up most of my time is getting the VGA display output working. VGA is a much more complicated protocol than I have worked with before and has strict requirements to get the correct image displaying. It will be interesting to figure out how to do this in an effective way on the FPGA. Looking forward to the challenge and learning lots more about unique digital designs!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Jordan Carlin is a junior engineering major at Harvey Mudd College interested in computer engineering and digital design. He is currently doing research as a Clay-Wolkin Fellow at Harvey Mudd’s VLSI lab working on a superscalar implementation of the open-source OpenHW-Group CVW RISC-V SoC. He has experience with SystemVerilog and RISC-V assembly and would love to continue growing his computer engineering skills. He’s always excited to learn new things and would be happy to connect with you!"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to read a 4-bit binary input from two sets of switches and display both numbers on a 2-digit seven-segment display. The sum of the two numbers is also computed and displayed in binary on a series of five LEDs. Time multiplexing is used to reduce the hardware cost of displaying two digits by using a single decoder module and set of output pins."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to read a 4-bit binary input from two sets of switches and display both numbers on a 2-digit seven-segment display. The sum of the two numbers is also computed and displayed in binary on a series of five LEDs. Time multiplexing is used to reduce the hardware cost of displaying two digits by using a single decoder module and set of output pins."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe overall project was broken up into several smaller Verilog modules. A simple adder and the 7-segment display decoder from Lab 1 were combined with a new pulse module that contained most of the logic. The pulse module takes both sets of switches as inputs and, using a counter to produce a slower clock, alternates which set of switches is sent to the 7-segment decoder. It also ensures that the appropriate anode is activated.\nThe physical design was setup to ensure that the maximum current from the FPGA pins was not exceeded, which necessitated the use of transistors to drive the 7-segment displays.\nThe Verilog modules were tested using a testbench that applied testvectors covering most corner cases (extremes in this case) along with several other random vectors. It did not seem necessary to test every possible input combination as that number quickly explodes. The physical design was tested using a wide variety of different possible inputs."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe source code for the project can be found in the associated GitHub repository.\n\nBlock Diagram\n\n\n\n\n\n\nFigure 1: Block diagram of the Verilog design.\n\n\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The various modules are described here:\n\n\n\n\n\n\n\nSystemVerilog Module\nDescription\n\n\n\n\nlab2_jc\nFPGA specific module, includes high speed oscillator module\n\n\ntop\nTop-level, non FPGA-specific module\n\n\nseg_decoder\n7-segment display decoder\n\n\npulse\nRapidly switches which digit of the display is active\n\n\nadder\nComputes the sum of the two inputs\n\n\n\n\n\nSchematic\n\n\n\n\n\n\nFigure 2: Schematic of the physical circuit.\n\n\n\nFigure 2 shows the physical layout of the design.\n\nAn internal 100 k\\(\\Omega\\) pullup resistor was used to ensure the input switches were not floating.\nThe transistors were connected to the FPGA through a 330 \\(\\Omega\\) current-limiting resistor to ensure that they didn’t pull more than 8 mA, the maximum the FPGA I/O pins can supply (see table 4.13 of the FPGA datasheet). Per their datasheet, the transistors have a voltage drop of 0.65 V, so 330 \\(\\Omega\\) works perfectly based on Ohm’s Law.\nThe LEDs in the 7-segment display have a voltage drop of 2.1 V (datasheet), so a current-limiting resistor of 150 \\(\\Omega\\) limits the current through the FPGA to 8 mA.\nThe output LEDs for the sum have a voltage drop of 2.35 V (datasheet), so 120 \\(\\Omega\\) current-limiting resistors were selected."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\n\n\n\nFigure 3: A screenshot of a QuestaSim simulation.\n\n\n\nFigure 3 shows a screenshot of the QuestaSim simulation validating the Verilog. The physical design works when deployed on the FPGA. The design meets all intended design objectives and specifications."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully displays two digits on the 7-segment display at the same time with only one set of pins by utilizing time-multiplexing. The LEDs show the correct sum for all input digits.\nI spent a total of 13 hours working on this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "In this lab, an ARM microcontroller was used to measure the rotational speed and direction of a motor using a quadrature encoder. Pulses from this encoder were detected using interrupts to achieve a high degree of accuracy and precision."
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "In this lab, an ARM microcontroller was used to measure the rotational speed and direction of a motor using a quadrature encoder. Pulses from this encoder were detected using interrupts to achieve a high degree of accuracy and precision."
  },
  {
    "objectID": "labs/lab5/lab5.html#design-methodology",
    "href": "labs/lab5/lab5.html#design-methodology",
    "title": "Lab 5: Interrupts",
    "section": "Design Methodology",
    "text": "Design Methodology\nI used a series of different libraries from the examples for this course as the starting point for my design. I used the GPIO, RCC, and TIM libraries nearly unchanged. On top of these libraries, I implemented control of several of the EXTI interrupts controllers. The main design challenge for this lab was deciding how many interrupts to have and figuring out how to determine both speed and direction from these interrupts.\nI ended up settling on using one interrupt handler that gets called when there is an interrupt on either of the two encoder channels. This interrupt handler increases a variable counting the number of pulses each time it is called and updates an array with the status of the encoder (which channel was triggered and if it was rising or falling). The new state is compared to the state that was stored on the previous interrupt. Quadrature encoders are 90° out of phase, so the transition pattern is unique depending on which direction the motor is spinning. A checkDirection function compares which transition took place to a list of conditions to determine which direction the motor must be spinning. Using a timer, the number of pulses is checked after each second. This number of pulses is divided by 480 (the number of pulses per rotation * 2 channels counting pulses * counting twice because using the rising and falling edge) and output as the current speed in revolutions/sec. The variable tracking the number of pulses is then cleared to being counting for the next second.\nThis approach gains all of the benefits of using interrupts over timers (see below) without needing to strike a careful balance of different timers and frequencies. A single timer is used just to check the number of pulses each second, so it was initialized to run at a 1 ms clock rate and a simple delay_millis function could be used."
  },
  {
    "objectID": "labs/lab5/lab5.html#technical-documentation",
    "href": "labs/lab5/lab5.html#technical-documentation",
    "title": "Lab 5: Interrupts",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe source code for the project can be found in the associated GitHub repository.\n\nSchematic\n\n\n\n\n\n\nFigure 1: Schematic of the physical circuit.\n\n\n\nFigure 1 shows the physical layout of the design.\nA 25GA-370 DC Motor was used as the motor/encoder for this lab.\n\n\nFlowchart\n\n\n\n\n\n\nFigure 2: Flowchart of the program logic and control flow. This shows how interrupts are handled and interface with the main loop.\n\n\n\nFigure 2 shows control flow of the program. The main loop is executing on the left and the interrupt handler that is triggered whenever an encoder channel pulses is on the right."
  },
  {
    "objectID": "labs/lab5/lab5.html#results-and-discussion",
    "href": "labs/lab5/lab5.html#results-and-discussion",
    "title": "Lab 5: Interrupts",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nTo test my motor I connected it to a power supply and varied the voltage while it was connected to my circuit. First I ran it at very low speeds in both directions to visually check that the reported direction was correct (it was). I also connected the encoder channels to an oscilloscope to check how many pulses the encoder was generating using a second method.\n\n\n\n\n\n\nFigure 3\n\n\n\nFrom Figure 3, the encoder pulsed 7 of times in 9 ms. There are 120 pulses per rotation, so the number of rotations is just the number of pulses from one channel divided by two. Scaling this up to a full second, this gives a speed of 6.48 rotations/sec. The MCU reported 6.325 rotations/sec as the speed at the same time. These speeds are close enough together that it seems like the MCU is accurate. If anything, I suspect that the MCU might be more accurate in this case because it is able to get more precise timings then I am from the oscilloscope. I repeated this test at speeds of 3.2 rotations/sec and 8.9 rotations/sec and had similar results.\n\nInterrupts vs Polling\nThe main focus of this lab was to learn about the use of interrupts and the benefits they provide over polling. Another possible approach to determine the speed of the motor could have skipped over interrupts and just used the GPIO pins as standard inputs. A timer could then be used to check the state of the inputs at some predetermined interval. If it is different than the previous state then it means a pulse had occurred. While this could have reasonable accuracy with a high polling rate and a low motor speed, it quickly falls apart if the motor is spinning fast enough for the MCU to miss pulses. If the encoder pulses high and back low in the time between a check, the pulse will be missed entirely. This will result in a lower speed than is appropriate for the motor. Interrupts avoid this problem because as soon as the state of the GPIO pin changes, the MCU stops its main thread and jumps to the code to check the state of the interrupt. This guarantees a rapid response to encoder pulses, significantly decreasing the changes of missing one."
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "Lab 5: Interrupts",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully reports the speed of a motor and its direction, updating every second. I spent a total of 9 hours on this lab."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab, an ARM microcontroller was used to drive a speaker to play different songs. The goal was to gain familiarity with the memory-mapped IO and timers that are present on the MCU. The program plays the provided song, Fur Elise, along with an additional song of my choice, Twinkle Twinkle Little Star."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab, an ARM microcontroller was used to drive a speaker to play different songs. The goal was to gain familiarity with the memory-mapped IO and timers that are present on the MCU. The program plays the provided song, Fur Elise, along with an additional song of my choice, Twinkle Twinkle Little Star."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-methodology",
    "href": "labs/lab4/lab4.html#design-methodology",
    "title": "Lab 4: Digital Audio",
    "section": "Design Methodology",
    "text": "Design Methodology\nI used a series of different libraries from the examples for this course with several modifications specific to this lab. I used the GPIO and RCC libraries nearly unchanged, but heavily modified the timer library to make it easier to work with for this lab. See the source code below for full details, but I set up two timer, one in a normal count-up mode and one in its special PWM mode. I used the one in PWM mode to get the desired output frequency, making sure to keep the duty cycle at 50% to not throw off the sound. Both timers needed careful thought regarding the appropriate values to set for their different registers to ensure they were able to play all of the desired frequencies and hold for all the necessary durations.\nFor the second song that I played, I chose Twinkle Twinkle Little Star (sheet music here) because I knew that it had a small range of notes that would be able to fit into the system that I had designed. Instead of converting each note to its respective frequency, I used the note names in the array and set up additional #define macros to replace those notes with the appropriate frequency. This made the process of creating the array for the song far easier than it otherwise would have been."
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab 4: Digital Audio",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe source code for the project can be found in the associated GitHub repository.\n\nSchematic\n\n\n\n\n\n\nFigure 1: Schematic of the physical circuit.\n\n\n\nFigure 1 shows the physical layout of the design.\nThe LM386 was used to drive the speaker because the GPIO pins of the MCU are not able to provide sufficient current themselves.\n\n\nTimer Calculations\nI used a 40 MHz system clock by configuring the PLL. This specific frequency was not all that important, but it needed to be high enough to achieve the desired output frequencies without being too high and preventing the other timer from reaching the necessary durations. 40 MHz seemed like a good balance.\nFor the PWM timer driving the speaker, I chose a prescale value that brought the frequency down to 100 kHz. This made the calculations for the other registers very simple. The ARR field controls the PWM frequency. By setting it to 100 kHz divided by the desired frequency, we get the necessary divisor. This then needs to be cut in half since it is a PWM wave that will be run at 50 % duty cycle. The register controlling the duty cycle (CCR2) gets half of this calculated frequency to ensure it remains at 50 %. These values are updated every time the note changes. This gives a maximum frequency of 50 kHz (if no additional dividing is done by ARR) and a minimum frequency of 100 kHz divided by 2^16, which is 1.526 Hz. This more then covers our range of 220 Hz to 1 kHz.\nThe divider that controls the frequency can be up to 1 off from the correct value because of integer rounding when doing division. This results in a potential frequency error of one clock cycle. The clock is running at 100 kHz, so one clock cycle is 1 ms. For the frequencies of interest, this results in the following errors:\n\n\n\nFrequency\nIdeal Period\nPotential Error Period\n\n\n\n\n220 Hz\n454.545 ms\n454/455 ms\n\n\n1000 Hz\n100 ms\n99/101 ms\n\n\n\nThese are both within the required 1% of the desired frequency.\nFor the timer that is counting duration, I used the prescaler to 1 kHz. The slower clock allows us to count to higher values, and we never this counter to be going very fast. This means that the minimum time we can set for a delay will be 1 ms and the maximum will be 65,536 ms. This is determined by dividing the minimum and maximum values (1 and 2^16) by the prescale frequency, 1 kHz."
  },
  {
    "objectID": "labs/lab4/lab4.html#results-and-discussion",
    "href": "labs/lab4/lab4.html#results-and-discussion",
    "title": "Lab 4: Digital Audio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nTo test my frequencies, I used the tuning app “Tuner T1” and found that they were all correct to within a couple of hertz, which is well within the 5% tolerance for the frequency. Mathematical calculations supporting this same conclusion are provided in the next section."
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "Lab 4: Digital Audio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully plays two songs in series on a speaker. It uses a potentiometer to control the volume and all of the pitches and frequencies are correct.\nI spent a total of 17 hours working on this lab."
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard-aes",
    "href": "labs.html#lab-7-the-advanced-encryption-standard-aes",
    "title": "Labs",
    "section": "Lab 7: The Advanced Encryption Standard (AES)",
    "text": "Lab 7: The Advanced Encryption Standard (AES)"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In Lab 1, the overall goal was to ensure our E155 Development Boards were working correctly and to learn about the process of programming the FPGA and MCU. Both boards (FPGA and MCU) were initially programmed with example code to ensure the software flow was working. Afterwards, the FPGA was programmed with a custom design to control a 7-segment display and several LEDs based on a series of DIP switches."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In Lab 1, the overall goal was to ensure our E155 Development Boards were working correctly and to learn about the process of programming the FPGA and MCU. Both boards (FPGA and MCU) were initially programmed with example code to ensure the software flow was working. Afterwards, the FPGA was programmed with a custom design to control a 7-segment display and several LEDs based on a series of DIP switches."
  },
  {
    "objectID": "labs/lab1/lab1.html#fpga-design",
    "href": "labs/lab1/lab1.html#fpga-design",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "FPGA Design",
    "text": "FPGA Design\n\nTask\nPer the provided specifications for the lab, 4 DIP switches should be used as inputs to control the following outputs:\n\n\n\nOUTPUT\nINPUT\nOPERATION\n\n\n\n\nLED 0\nS[0:1]\nXOR\n\n\nLED 1\nS[2:3]\nAND\n\n\nLED 2\n48 MHz clock\n2.4 Hz blink\n\n\n7-Segment Display\nS[0:3]\nbinary decoder\n\n\n\n\n\nApproach\nTo aid in debugging and reusability, I broke this into several SystemVerilog modules, each contained within its own file. I used the following modules:\n\n\n\nSystemVerilog Module\nDescription\n\n\n\n\nlab1_jc\nFPGA specific module, includes clock module\n\n\ntop\ntop-level, non FPGA-specific module\n\n\nseg_decoder\n7-segment display decoder\n\n\npulse\nOutput pulse of desired frequency based on clk\n\n\n\nThe following block diagram shows how these modules fit together and the inputs/outputs of each.\n\nThe FPGA-specific module can be found here and all of the other SystemVerilog modules are here.\n\n\nTesting\nI ran into lots of issues with QuestaSim on my personal computer (tried both Linux and Windows), but was eventually able to get it running by manually recompiling the files from within the Questa GUI. I’ll probably switch to using the vsim cli going forwards to avoid issues and automate this process.\nOnce I had Questa working, I created a testbench to verify my Verilog was working correctly. Since all of the modules are very simple in this case, I went with a single top-level testbench that runs on the top module (excluding the FPGA specific components). This testbench loads a series of testvectors that simulate all of the possible combinations of switches and checks that LEDs 0 and 1 along with the 7-segment display have the appropriate outputs.\nThe resulting waveform is pictured below.\n\nWhen run, the testbench finishes with the following message, indicating a successful run.\n16 tests completed with 0 errors."
  },
  {
    "objectID": "labs/lab1/lab1.html#hardware",
    "href": "labs/lab1/lab1.html#hardware",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Hardware",
    "text": "Hardware\n\nBoard Assembly\nWith this particular lab, there was more to do from a hardware perspective than a design perspective. After soldering all of the components to my board, I was having weird power issues where it worked with an input voltage from the 6 V line from a power supply but not the 20 V line (no matter how low that line was set). After lots of troubleshooting, I eventually traced it down to a bad solder joint and after reflowing it the board was working correctly.\nUnfortunately, one of my ribbon cable connectors came broken, and I was unable to find any others. I temporarily clamped the connector on with its one functional latch and was able to get about half of the pins working, which was enough for this lab. This connector will need to be replaced in the future.\nThe assembled board can be seen here:\n\n\n\n7-Segment Display Circuit\nThe 7-segment display uses a common anode, which means that one pin will be connected to power (3.3 V) and all of the other pins will get connected (through a current-limiting resistor) to IO pins in the FPGA. When these pins are pulled low the corresponding LED will turn on.\n\nResistor Calculation\nTo determine the appropriate resistor value, I used the forward voltage and current ratings from the 7-segment display datasheet. According to the datasheet, the voltage drop is typically 2.1 V, so with a 3.3 V supply voltage the resistor will have 1.2 V going through it. I wanted to keep the current fairly low to reduce power draw while ensuring the LEDs were bright enough to see, so I targeted a current between 10 mA and 20 mA (the currents used for luminous intensity rating and calculating voltage respectively). Using R=VI this gives a desired resistor of between 60 Ω and 120 Ω. I ended up using 100 Ω resistors, which results in 12 mA of current.\n\n\n\nSchematic\nThe overall schematic for the circuit includes the FPGA, DIP switches, LEDs, and 7-segment display. It is shown below."
  },
  {
    "objectID": "labs/lab1/lab1.html#results",
    "href": "labs/lab1/lab1.html#results",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results",
    "text": "Results\nThe final design meets all of the specifications for this lab. The E155 development board is fully assembled and functional (barring the replacement of the broken ribbon cable connector). The FPGA is programmed with synthesized Verilog that is driving the LEDs and 7-segment display per the provided guidelines and has been tested both in simulation using a testbench and in hardware. The 7-segment display is capable of displaying all of the digits in a unique manner with constant brightness."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3 - Keypad Scanner",
    "section": "",
    "text": "In this lab, a design was implemented on an FPGA to scan a 16-button keypad for input and display the input characters on a 2-digit seven-segment display. 2 characters are displayed at a time and they are retained until new characters are input. The system is resistant to switch bouncing and multiple button presses."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3 - Keypad Scanner",
    "section": "",
    "text": "In this lab, a design was implemented on an FPGA to scan a 16-button keypad for input and display the input characters on a 2-digit seven-segment display. 2 characters are displayed at a time and they are retained until new characters are input. The system is resistant to switch bouncing and multiple button presses."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab 3 - Keypad Scanner",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe overall project was split up into several smaller Verilog modules. See Table 1 for all of the modules. At a high level, the system was broken down into dedicated decoders for the keypad and 7-segment display, a controller FSM, and several counters. A synchronizer was also used to avoid metastability from the asynchronous inputs. Many of the modules from Lab 2 were used almost unchanged to drive the 7-segment display logic. The main design challenge came in the FSM, which also incorporated switch debouncing and the control logic to retain previous numbers. This is explained in more detail in the FSM section.\nThe physical design was setup to ensure that the maximum current from the FPGA pins was not exceeded, which necessitated the use of transistors to drive the 7-segment displays. The keypad was setup to use pull-up resistors so that the internal FPGA resistors could be used.\nThe Verilog modules were tested using several testbenches that applied testvectors covering a variety of different possible inputs. It did not seem necessary to test every possible input combination as that number quickly explodes. The physical design was tested using a wide range of different possible inputs."
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab 3 - Keypad Scanner",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe source code for the project can be found in the associated GitHub repository.\n\nBlock Diagram\n\n\n\n\n\n\nFigure 1: Block diagram of the Verilog design.\n\n\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The various modules are described here:\n\n\n\nTable 1: Verilog Modules\n\n\n\n\n\n\n\n\n\nSystemVerilog Module\nDescription\n\n\n\n\nlab3_jc\nFPGA specific module, includes high speed oscillator module\n\n\ntop\nTop-level, non FPGA-specific module\n\n\nsync\nSynchronizer with two flops\n\n\nkey_scan\nMain FSM module to drive keypad row scanning and updating of stored numbers\n\n\ncounter\nCounter used to reduce the speed of the clock\n\n\nkey_decoder\n16-button keypad decoder\n\n\nseg_decoder\n7-segment display decoder\n\n\npulse\nRapidly switches which digit of the 7-segment display is active\n\n\n\n\n\n\n\n\nFinite-State Machine\nThe following state transition diagram and table explain the operation of the main key_scan fsm. In addition to the state and inputs, the FSM is also reliant on a counter to determine several of the state transitions. This counter is reset or incremented depending on the current state and is used to address the latency introduced by the synchronizer and avoid switch bouncing.\nFor switch bouncing in particular, the POSSIBLE_PRESSED state only transitions to the PRESSED state if a button is held down for 15 continuous clock cycles. This will avoid counting any bouncing as a press. Once in the WAITING state (which happens after a button is pressed) the FSM does not resume scanning until after the button is released and a set period of time (300 clock cycles) has elapsed. This approach introduces some additional latency, but due ot the relatively high speed of the clock it is not enough to make a difference to the user so seems like an acceptable debouncing strategy.\n\n\n\n\n\n\nFigure 2: State transition diagram of key_scan fsm\n\n\n\n\n\n\nTable 2: State Transition Table of key_scan fsm\n\n\n\n\n\n\n\n\n\n\nCurrent State\nOutputs\nNext State\n\n\n\n\nIDLE\nclearCounter = 1\nR0\n\n\nR0\nclearCounter = 1\nrowChange = 1\nnewRows = 0001\nR0_CHECK\n\n\nR1\nclearCounter = 1\nrowChange = 1\nnewRows = 0010\nR1_CHECK\n\n\nR2\nclearCounter = 1\nrowChange = 1\nnewRows = 0100\nR2_CHECK\n\n\nR3\nclearCounter = 1\nrowChange = 1\nnewRows = 1000\nR3_CHECK\n\n\nR0_CHECK\nincCount = 1\n|cols: POSSIBLE_PRESSED\ncounter ≥ SYNC_DELAY: R1\nR0_CHECK\n\n\nR1_CHECK\nincCount = 1\n|cols: POSSIBLE_PRESSED\ncounter ≥ SYNC_DELAY: R2\nR0_CHECK\n\n\nR2_CHECK\nincCount = 1\n|cols: POSSIBLE_PRESSED\ncounter ≥ SYNC_DELAY: R3\nR0_CHECK\n\n\nR3_CHECK\nincCount = 1\n|cols: POSSIBLE_PRESSED\ncounter ≥ SYNC_DELAY: R0\nR0_CHECK\n\n\nPOSSIBLE_PRESSED\nincCount = 1\n|cols & counter ≥ DEBOUNCE: PRESSED\ncounter ≥ DEBOUNCE: IDLE\nPOSSIBLE_PRESSED\n\n\nPRESSED\nnewNum = 1\nWAIT\n\n\nWAIT\nincCount = 1\n~|cols & counter ≥ DELAY: IDLE\nWAIT\n\n\n\n\n\n\n\n\nSchematic\n\n\n\n\n\n\nFigure 3: Schematic of the physical circuit.\n\n\n\nFigure 3 shows the physical layout of the design. Internal resistors are used as much as possible, so a pull-up configuration was chosen for the keypad."
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Lab 3 - Keypad Scanner",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\n\n\n\nFigure 4: Top level simulation.\n\n\n\n\n\n\n\n\n\nFigure 5: Detailed simulation of key decoder.\n\n\n\nFigure 4 shows a screenshot of the QuestaSim simulations validating the overall Verilog. Figure 5 shows a more detailed simulation testing the key decoder module with all possible inputs. The physical design works when deployed on the FPGA. The design meets all intended design objectives and specifications."
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab 3 - Keypad Scanner",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully displays two digits on the 7-segment display based on the characters that are input using the keypad. The numbers persist after the keys are released and cycle off to the left as new keys are pressed.\nI spent a total of 27 hours working on this lab."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab, an ARM microcontroller was used to control an SPI based temperature sensor. The data from this MCU was then supposed to be sent via UART to an ESP that hosted a webserver. The temperature could be viewed on the website and the precision of the sensor could be changed as well. Unfortunately, the ESPs are very finicky and mine was unable to successfully communicate with the MCU despite many attempts with several boards. I will touch on the ESP throughout the report, but the focus will be on the SPI temperature sensor since that is what I actually got working."
  },
  {
    "objectID": "labs/lab6/lab6.html#introduction",
    "href": "labs/lab6/lab6.html#introduction",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab, an ARM microcontroller was used to control an SPI based temperature sensor. The data from this MCU was then supposed to be sent via UART to an ESP that hosted a webserver. The temperature could be viewed on the website and the precision of the sensor could be changed as well. Unfortunately, the ESPs are very finicky and mine was unable to successfully communicate with the MCU despite many attempts with several boards. I will touch on the ESP throughout the report, but the focus will be on the SPI temperature sensor since that is what I actually got working."
  },
  {
    "objectID": "labs/lab6/lab6.html#design-methodology",
    "href": "labs/lab6/lab6.html#design-methodology",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Design Methodology",
    "text": "Design Methodology\nI used a series of different libraries from the examples for this course with several modifications specific to this lab. The bulk of the design work for this lab was creating an SPI library for the MCU. I used the template that was discussed in class to set up a library that defined two functions, an init function and a transmit/receive function. These were built using the CMSIS headers, which made the process much more straightforward. The initialization function sets clocks, pin modes, and various registers to configure baud rate and polarity.\nI also created a library for the temperature sensor to make reuse easy. This library has a function to set the precision of the sensor and another to get the current temperature. These are built on top of the SPI library that I already built. They send the necessary SPI packets to read/write to the necessary registers and ensure that the chip enable signal is high at the appropriate times.\nAn earlier version of my code for this project also included UART packets being sent from the MCU to the ESP to create the webpage and requests being sent back to the MCU from the ESP along that same UART protocol. These controlled the precision setting for the sensor, but since the ESP has been removed from my system I am just using a hardcoded value that gets passed to the function and can be changed at compile time."
  },
  {
    "objectID": "labs/lab6/lab6.html#technical-documentation",
    "href": "labs/lab6/lab6.html#technical-documentation",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe source code for the project can be found in the associated GitHub repository.\n\nSchematic\n\n\n\n\n\n\nFigure 1: Schematic of the physical circuit.\n\n\n\nFigure 1 shows the physical layout of the design.\nThe DS1722 temperature sensor was used in SPI mode.\n\n\nSPI Trace\n\n\n\n\n\n\nFigure 2: SPI trace of communication between temperature sensor and MCU during a temperature read.\n\n\n\nFigure 2 shows the communication between the temperature sensor and the MCU during a temperature read."
  },
  {
    "objectID": "labs/lab6/lab6.html#results-and-discussion",
    "href": "labs/lab6/lab6.html#results-and-discussion",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nTo test the temperature sensor, I checked the temperature at room temperature and compared it to what the AC in the lab said. The AC said 22 °C and the sensor reported 21.75 °C. This seems to be within a reasonable margin of error. I also tested warming the sensor up by pressing my finger on it and cooling it down with compressed air. In both cases the sensor responded accordingly. It was also capable of hitting compressed temperatures when using the compressed air."
  },
  {
    "objectID": "labs/lab6/lab6.html#conclusion",
    "href": "labs/lab6/lab6.html#conclusion",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully communicates with an SPI temperature sensor, sets its precision, and reports the current temperature. Due to issues with the ESP, this temperature is printed via the debug interface instead of being sent to a webserver.\nI spent a total of 17 hours working on this lab."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "HMC E155 Course Website"
  },
  {
    "objectID": "posts/week-3-blog.html",
    "href": "posts/week-3-blog.html",
    "title": "MicroPs Week 3 Reflections",
    "section": "",
    "text": "Wow! What a week. I knew that the keypad scanner lab was a notoriously difficult one, but I still wasn’t expecting this! I went into it fairly confident. I quickly created a state transition diagram for an FSM that I thought would do what I needed, wrote some Verilog, and wired up my circuit. I was expecting there to be some bugs when I fired up the system for the first time, but I was expecting them to be fairly minor and for the debugging process to be fairly painless (like it had been for the other labs). How wrong I was. My initial attempt gave me nothing but zeroes on the display no matter what buttons I pushed. Even 20 hours down the road, I’m still seemingly pretty far from a working system. After changing my FSM, rewiring parts of my circuit, and hours of investigating with an oscilloscope, I have some numbers appearing correctly occasionally. That’s far from where I wanted to be at this point. Up until now in E85 and in MicroPs I’ve gotten lucky (and just been dealing with simpler systems) with my designs and have had to do fairly little debugging. This lab has been an eye-opening experience into just how wrong things can go and how hard it can be to nail down the little details and figure out exactly why something isn’t working. While I’ve spent far too long on this lab already, I’m enjoying the process and am learning a lot about troubleshooting. Looking forward to finally getting it working the way it should be!"
  },
  {
    "objectID": "posts/week-8-blog.html",
    "href": "posts/week-8-blog.html",
    "title": "MicroPs Week 8 Reflections",
    "section": "",
    "text": "This week was the North American RISC-V Summit, which technically isn’t directly related to this class, but has many clear connections. As a Clay-Wolkin Fellow and member of Harvey Mudd’s VLSI lab, I was at the summit and thought it would be a great topic for this blog post.\nWhile I was only at the conference for two days, there was so much happening! From technical sessions to product launches to a career fair to a demo area with the latest RISC-V boards, there was always something going on. While many of these more formal events were interesting, it was the people at the event that was easily the best part. Getting the chance to have all sorts of different conversations (technical and not) with many of the biggest names in the world of RISC-V was amazing, and meeting many of the people that I’ve worked with via GitHub or Zoom in person was great. It truly was a one of a kind experience being surrounded by so many people that were all so knowledgeable about the field.\nWhile I had many of these impromptu conversations, some of the most interesting were the meetings we had scheduled in advance with various groups. By far the most notable of these was during dinner Tuesday night. A group of 16 of us (including the entire team from Mudd, a group from Cambridge, some of the Sail developers, some of the Architectural Compatibility Test developers, someone from the OpenHWGroup, and several others) met to discuss verification, certification, and compatibility testing. This is a big topic at RISC-V International right now and there is a lot of work being put in to figuring out what the future of this will look like. Being a part of this discussion that has the potential to influence a large number of individuals and companies as a sophomore is not something that I would have thought possible, but really was an incredible experience. While some it was, unsurprisingly, over my head, I was still able to make tangible contributions to many parts of the conversation and I am looking forward to seeing where it goes from here."
  },
  {
    "objectID": "posts/week-2-blog.html",
    "href": "posts/week-2-blog.html",
    "title": "MicroPs Week 2 Reflections",
    "section": "",
    "text": "Hard to believe that we’re already over a quarter of the way done with the labs for MicroPs. I had a lot more fun with this lab than the previous one because it gave me a chance to dive into more digital design and (mostly) move on from fighting with tools (I still can’st seem to program the FPGA from my computer). While the seven-segment display decoder was fairly simple and basically just reused my module from last week, the pulse module that allowed for two digits to be driven using time-multiplexing was a bit more of a challenge. While the final logic ended up being fairly elegant, it took a while to think through some of the edge cases and picking an appropriate frequency to switch between the digits also took some trial and error.\nI had an interesting bug that caused one of my digits to occasionally be off by one from the input number, and it seemed to be happening inconsistently. The variability of it and the fact that my design worked in simulation led me to believe it was a hardware problem, and after a lot of very meticulous debugging with a much slower switching frequency. I traced it down to one of my input pins not working consistently. After switching to a different pin everything worked correctly, but I still need to investigate what the problem with the other pin was. I’m assuming a soldering issue. I will likely need to figure this out for next week or I suspect I will run out of pins. Looking forward to a much more complicated design project for the next lab."
  },
  {
    "objectID": "posts/week-9-blog.html",
    "href": "posts/week-9-blog.html",
    "title": "MicroPs Week 9 Reflections",
    "section": "",
    "text": "The semester really has flown by. I’m working on finishing up all of the remaining labs in the next few days. I need to do most of labs 6 and 7 and finish up lab 5 by the end of the week. While that’s certainly a lot of work to do on the labs, I want to shift my focus to the final project for this blog post. As I introduced in my post a few weeks ago, Zoe and I are working on a cross between etch-a-sketch and the python turtle graphics program. The user will have a joystick to control what they are drawing and buttons/sliders to control the color, brush width, and whether or not the pen is down. With the design review presentations coming up next week, I want to take this space to talk about one of the main questions we’re still trying to figure out that we’re hoping to get advice on from our peers.\nOne of the big challenges with displaying graphics is the sheer amount of data needed to represent everything. Constantly transmitting all of this information between the MCU and FPGA would be wildly inefficient and slow, so we plan to use the FPGA’s onboard memory banks as the main storage location for all of this. This keeps the data close to the display driver that actually needs all of this data. While this is great, it also poses a new dilemma: how the MCU and FPGA should communicate. The MCU will be getting the inputs from the user, so it needs to transmit what needs to change to the FPGA. We’re planning to do this using the SPI protocol, but exactly what data should be transmitted and how to encode it is still up in the air.\nThere are some parts that are fairly clear. We will definitely need to pass the color that is being drawn as part of the data packet and it will likely be encoded in a 3 bit binary representation to cover the 7 options that the user has. The data for the timer will probably be transmitted as a separate data packet distinct from the main drawing one that is sent once a second. The rest of the data in the drawing packet is where it gets tricky though. Most likely the MCU will need to keep track of the current location of the brush. It will then need to transmit which pixels need to change color. This could potentially be done by passing 2 corners of a rectangle that it calculates based on the current location and brush width. Alternatively, it could transmit just the location and brush width and the FPGA could then determine which pixels that means need to change. If we wanted to push even more onto the FPGA it could even just transmit which direction the brush is moving and all of the state about current location could be kept on the FPGA. This would require it to calculate the new position instead of the MCU. Balancing the computation being done on the MCU and FPGA with the amount of data that needs to be transmitted is going to be an interesting challenge and we’re looking forward to seeing if any of the other students in MicroPs have good suggestions for this."
  },
  {
    "objectID": "posts/learning-goals.html",
    "href": "posts/learning-goals.html",
    "title": "Initial Learning Goals",
    "section": "",
    "text": "I’m very excited to begin my journey into the world of microprocessors and embedded systems in this class. While I have some experience with FPGAs from my internship with Masimo this past summer, they’re still relatively new to me and I’m looking forward to learning more about the ins and outs of how to use them. I’m also interested in learning more about when to use an FPGA vs MCU and how to program an ARM MCU (most of my experience so far is with RISC-V)."
  },
  {
    "objectID": "posts/week-4-blog.html",
    "href": "posts/week-4-blog.html",
    "title": "MicroPs Week 4 Reflections",
    "section": "",
    "text": "It may have taken some extra time, but I finally got my keypad scanner working this week! Turns out methodical debugging really does work. After hooking my circuit up to a logic analyzer to see all of the rows and columns simultaneously (previously I was looking at just two of the eight signals at a time on the oscilloscope), the problem quickly became apparent. Due to a flaw in my FSM, whenever a button was pushed it looked at the next row to which key was being pressed. I solved this by adding in an extra cycle of latency (and later several more cycles of latency to account for the synchronizer) between the scanning states.\nIt had been a while since I’d thought deeply about FSMs, but coincidentally E85 has been doing FSMs for their labs the last two weeks as well. As a TBP tutor for E85, it was interesting to see the FSMs that they were coming up with and struggling to get working in parallel with my own FSM. While this FSM is much more complicated than the ones they are working on, the ideas and issues are very similar. Several of them were missing states that they needed or had thought about some of their transitions incorrectly, just like I had. In a lot of ways helping all of them debug their FSMs helped me think through debugging my own FSM. It’s always been said that teaching others makes your own understanding of a concept that much stronger, and it really is true."
  }
]