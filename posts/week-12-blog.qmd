---
title: "MicroPs Week 12 Reflections"
description: "The Home Stretch"
author: "Jordan Carlin"
date: "12/3/24"
categories:
  - reflection
draft: false
---

Wow! This semester really has flown by. Somehow it is already the final week of the semester and we are just days away from the end of the final project. It's been a little while since my last reflection because of Thanksgiving. In the time since that last post I finished up all of the labs (lots of small details had to be ironed out still) and have been working extensively on the final project.

Pictionary is proving to be significantly more troublesome than initially envisioned. While Zoe was able to get an initial version of the MCU implementation that reads the user inputs and send them to the FPGA as a SPI packet put together fairly quickly, the FPGA work has been another story entirely. It has gone from one issue to another and there is not really an end in sight for it yet. One of the significant challenges we were facing with it for a while was the block ram. We were trying to use a block ram to store the current image data, but Lattice refused to synthesize our Verilog into a block RAM. The closest we were able to get for a while was it detecting that we wanted a RAM but it claiming that there were no available RAMs that matched. We finally solved this issue by uisng the built-in EBR IP block generator and manually instantianting the module that ir produced, similar to the PLL. We're also dealing with some pretty significant issues with the display itself. The whole image is very jittery and spikes run up and down the display fairly consistently. This makes it seem as though it is a timing issue, but we can't nail down what is going on there. Even more problematically, the image is either not being written or read (or maybe both) from the RAM properly. There are seemingly random reginos that it is able to write/read from and others that it just outputs black. We haven't been able to figure out the rhyme or reason for this so far. There is a lot to do in the next few days to get this project to the finish line, but I'm looking forward to the final result.

One interesting thing that I've been experimenting with throughout the project is AI. Unlike with the labs, we are allowed to use AI to assist us with the final project. I've been using Copilot in VSCode while writing all of the Verilog, and have had it assist me in writing some of the code. The most notable examples have been testbenches. While it may not be perfect, with a very simple prompt I've found that Copilot is able to generate a testbench that properly instantiates my desired module, declares all the necessary signals, generates a clock, and applies reset. This means I can focus on just writing the testcases themselves and not on the fairly standard testbench code. For some of the testbenches it even created testcases for me without me asking for them. I had to tweak them a bit, but they were shockingly close to what I would have written myself. Beyond just testbenches, I've also used it to help generate several of the more standard modules that we've needed, like a synchronizer and one of the fairly simple SPI modules. Overall, I've found it to be shockingly useful and I'm excited to continue experimenting with it. While the code that it produces is never perfect, it has without a doubt saved me time and allowed me to focus on the tricker parts of the project.
