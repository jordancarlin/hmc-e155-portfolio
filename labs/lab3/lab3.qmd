---
title: "Lab 3 - Keypad Scanner"
---

## Introduction

In this lab, a design was implemented on an FPGA to scan a 16-button keypad for input and display the input characters on a 2-digit seven-segment display. 2 characters are displayed at a time and they are retained until new characters are input. The system is resistant to switch bouncing and multiple button presses.


## Design and Testing Methodology

The overall project was split up into several smaller Verilog modules. See @tbl-modules for all of the modules. At a high level, the system was broken down into dedicated decoders for the keypad and 7-segment display, a controller FSM, and several counters. A synchronizer was also used to avoid metastability from the asynchronous inputs. Many of the modules from [Lab 2](https://github.com/jordancarlin/e155-lab2) were used almost unchanged to drive the 7-segment display logic.

<!-- The physical design was setup to ensure that the maximum current from the FPGA pins was not exceeded, which necessitated the use of transistors to drive the 7-segment displays.

The Verilog modules were tested using a testbench that applied testvectors covering most corner cases (extremes in this case) along with several other random vectors. It did not seem necessary to test every possible input combination as that number quickly explodes. The physical design was tested using a wide variety of different possible inputs. -->

## Technical Documentation:

The source code for the project can be found in the associated [GitHub repository](https://github.com/jordancarlin/e155-lab3).

### Block Diagram

::: {#fig-block-diagram}
![](images/block-diagram.png)

Block diagram of the Verilog design.
:::

The block diagram in @fig-block-diagram demonstrates the overall architecture of the design.
The various modules are described here:

| SystemVerilog Module | Description |
|:----:|:----:|
| `lab3_jc` | FPGA specific module, includes high speed oscillator module |
| `top` | Top-level, non FPGA-specific module |
| `sync` | Synchronizer with two flops |
| `key_scan` | Main FSM module to drive keypad row scanning and updating of stored numbers |
| `counter` | Counter used to reduce the speed of the clock |
| `key_decoder` | 16-button keypad decoder |
| `seg_decoder` | 7-segment display decoder |
| `pulse` | Rapidly switches which digit of the 7-segment display is active |

: Verilog Modules {#tbl-modules}

### Finite-State Machine

The following state transition diagram and table explain the operation of the main `key_scan` fsm. In addition to the state and inputs, the FSM is also reliant on a counter to determine several of the state transitions. This counter is reset or incremented depending on the current state and is used to address the latency introduced by the synchronizer and avoid switch bouncing.

For switch bouncing in particular, the POSSIBLE_PRESSED state only transitions to the PRESSED state if a button is held down for 15 continuous clock cycles. This will avoid counting any bouncing as a press. Once in the WAITING state (which happens after a button is pressed) the FSM does not resume scanning until after the button is released and a set period of time (300 clock cycles) has elapsed. This approach introduces some additional latency, but due ot the relatively high speed of the clock it is not enough to make a difference to the user so seems like an acceptable debouncing strategy.

::: {#fig-fsm}
![](images/fsm.png)

State transition diagram of `key_scan` fsm
:::

+------------------+--------------------+---------------------------------------+
| Current State    | Outputs            | Next State                            |
+:================:+:==================:+:=====================================:+
| IDLE             | `clearCounter = 1` | R0                                    |
+------------------+--------------------+---------------------------------------+
| R0               | `clearCounter = 1` | R0_CHECK                              |
|                  |                    |                                       |
|                  | `rowChange = 1`    |                                       |
|                  |                    |                                       |
|                  | `newRows = 0001`   |                                       |
+------------------+--------------------+---------------------------------------+
| R1               | `clearCounter = 1` | R1_CHECK                              |
|                  |                    |                                       |
|                  | `rowChange = 1`    |                                       |
|                  |                    |                                       |
|                  | `newRows = 0010`   |                                       |
+------------------+--------------------+---------------------------------------+
| R2               | `clearCounter = 1` | R2_CHECK                              |
|                  |                    |                                       |
|                  | `rowChange = 1`    |                                       |
|                  |                    |                                       |
|                  | `newRows = 0100`   |                                       |
+------------------+--------------------+---------------------------------------+
| R3               | `clearCounter = 1` | R3_CHECK                              |
|                  |                    |                                       |
|                  | `rowChange = 1`    |                                       |
|                  |                    |                                       |
|                  | `newRows = 1000`   |                                       |
+------------------+--------------------+---------------------------------------+
| R0_CHECK         | `incCount = 1`     | `|cols`: POSSIBLE_PRESSED             |
|                  |                    |                                       |
|                  |                    | `counter ≥ SYNC_DELAY`: R1            |
|                  |                    |                                       |
|                  |                    | R0_CHECK                              |
+------------------+--------------------+---------------------------------------+
| R1_CHECK         | `incCount = 1`     | `|cols`: POSSIBLE_PRESSED             |
|                  |                    |                                       |
|                  |                    | `counter ≥ SYNC_DELAY`: R2            |
|                  |                    |                                       |
|                  |                    | R0_CHECK                              |
+------------------+--------------------+---------------------------------------+
| R2_CHECK         | `incCount = 1`     | `|cols`: POSSIBLE_PRESSED             |
|                  |                    |                                       |
|                  |                    | `counter ≥ SYNC_DELAY`: R3            |
|                  |                    |                                       |
|                  |                    | R0_CHECK                              |
+------------------+--------------------+---------------------------------------+
| R3_CHECK         | `incCount = 1`     | `|cols`: POSSIBLE_PRESSED             |
|                  |                    |                                       |
|                  |                    | `counter ≥ SYNC_DELAY`: R0            |
|                  |                    |                                       |
|                  |                    | R0_CHECK                              |
+------------------+--------------------+---------------------------------------+
| POSSIBLE_PRESSED | `incCount = 1`     | `|cols & counter ≥ DEBOUNCE`: PRESSED |
|                  |                    |                                       |
|                  |                    | `counter ≥ DEBOUNCE`: IDLE            |
|                  |                    |                                       |
|                  |                    | POSSIBLE_PRESSED                      |
+------------------+--------------------+---------------------------------------+
| PRESSED          | `newNum = 1`       | WAIT                                  |
+------------------+--------------------+---------------------------------------+
| WAIT             | `incCount = 1`     | `~|cols & counter ≥ DELAY`: IDLE      |
|                  |                    |                                       |
|                  |                    | WAIT                                  |
+------------------+--------------------+---------------------------------------+

: State Transition Table of `key_scan` fsm {#tbl-state-transition}



### Schematic
::: {#fig-schematic}
![](images/schematic.png)

Schematic of the physical circuit.
:::

@fig-schematic shows the physical layout of the design.

<!-- - An internal 100 k$\Omega$ pullup resistor was used to ensure the input switches were not floating.
- The transistors were connected to the FPGA through a 330 $\Omega$ current-limiting resistor to ensure that they didn't pull more than 8 mA, the maximum the FPGA I/O pins can supply (see table 4.13 of the FPGA [datasheet](https://hmc-e155.github.io/assets/doc/FPGA-DS-02008-2-0-iCE40-UltraPlus-Family-Data-Sheet.pdf)). Per their [datasheet](https://www.onsemi.com/pdf/datasheet/2n3906-d.pdf), the transistors have a voltage drop of 0.65 V, so 330 $\Omega$ works perfectly based on Ohm's Law.
- The LEDs in the 7-segment display have a voltage drop of 2.1 V ([datasheet](https://www.alldatasheet.com/datasheet-pdf/view/118288/HP/HDSP-5721.html)), so a current-limiting resistor of 150 $\Omega$ limits the current through the FPGA to 8 mA.
- The output LEDs for the sum have a voltage drop of 2.35 V ([datasheet](https://www.lumex.com/datasheet/SSA-LXB10HW-GF+LP)), so 120 $\Omega$ current-limiting resistors were selected. -->

## Results and Discussion

<!-- ### Testbench Simulation

::: {#fig-testbench}

![](images/testbench.png)

A screenshot of a QuestaSim simulation.
:::

@fig-testbench shows a screenshot of the QuestaSim simulation validating the Verilog. The physical design works when deployed on the FPGA. The design meets all intended design objectives and specifications. -->

## Conclusion

<!-- The design successfully displays two digits on the 7-segment display at the same time with only one set of pins by utilizing time-multiplexing. The LEDs show the correct sum for all input digits. -->

I spent a total of 27 hours working on this lab.
